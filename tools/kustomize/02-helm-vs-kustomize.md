# Kustomize VS Helm

## Kustomize

#### 简介

- 是“如何封装应用”的解决方案，即“用配置文件来配置文件”
- 把应用中不变的信息与易变的信息隔离开（把应用所涉及的资源自动生成一个多合一的整合包，以解决部署的问题）
- Kustomize主要的价值是根据环境来生成不同的部署配置，只要建立多个Kustomization文件，开发人员就能以*基于基准进行派生*的方式，对不同模式（比如生产模式、调试模式）、不同项目（同一个产品对不同客户的定制化）定制出不同资源整合包


#### 流程

- 1. 开发阶段：配置文件中，无论是开发关心的信息，还是运维关心的信息，只要是在元数据中有描述的内容，最初都是开发人员编写
- 2. 编译阶段：编译期间由负责CI/CD的产品人员针对项目进行定制
- 3. 运维阶段：运维人员通过 kubectl 的补丁（Patch）机制更改其中需要运维取关注的属性（如：构造一个补丁来增加 Deployment 的副本个数、构造另外一个补丁来设置 Pod 的内存限制）

![kustomize-snapshot](/shot_screen/tools/kustomize/kustomize-snapshot.png)

#### 升华

- Kustomize 只是一个“小工具”性质的辅助功能
- 对于开发人员来说 Kustomize 只能简化产品针对不同情况的重复配置，并没有真正解决应用管理复杂的问题，要做的事情、要写的配置，最终都没有减少，只是不用反复去写
- 对于运维人员来说应用维护的不仅仅只是部署那一下，应用的整个声明周期，除了安装外还有更新、回滚、卸载、多版本、多实例、依赖项维护等诸多问题，都很麻烦


## Helm

#### 简介

- 由 Deis 公司开发的一种更具系统性的管理和封装应用的解决方案
- 如果说 Kubernetes 是云原生操作系统的话，Helm 是为这个操作系统上面的商店与包管理工具
- 类似于 Debian 系的 apt-get 命令与 dpkg 格式、THEL 系的 yum 命令与 rpm 格式
- 包管理工具掌握着应用的依赖信息和版本变更情况，具备完整的自管理能力，每个应用需要依赖哪些前置的第三方库，在安装的时候都会一并处理好
- Helm 提供了应用声明周期、版本、依赖项的管理能力
- Helm 还支持额外的扩展插件，能够加入 CI/CD 或者其他方面的辅助功能

#### 包

**Chart**

- 用于封装 Kubernetes 应用涉及到的所有资源，通常以目录内的文件集合的形式存在
- 目录名称就是 chart 的名称

![helm-snapshot](/shot_screen/tools/kustomize/helm-snapshot.png)

- Chart.yaml 中给出了应用自身的详细信息（名称、版本、许可证、自述、说明、图标等等）
- requirements.yaml 中给出了应用的依赖关系，依赖项指向的是另一个应用的坐标（名称、版本、 Respository地址）
- values.yaml 给出了所有可配置项的预定义值

**Respository**

- 主要用于实现 Chart 的搜索和下载服务
- 社区维护了公开的 Stable 和 Incubator 的中央仓库
- 支持组织搭建私有仓库

#### 升华

- Helm 支持对同一个 Chart 包进行多次部署，每次安装应用都会产生一个 Release，Release 相当于该 Chart 的安装实例
- 对于无状态的服务来说，依靠不同的 Release 就已经足够支持多个服务并行工作了
- 对于有状态的服务来说，服务会依赖特定资源或者服务产生依赖关系（如要部署数据库，通常要依赖特定的存储来保存持久化数据），就会将问题复杂化

**Reference:**
- [Helm vs Kustomize 如何选择 kubernetes 应用部署工具](https://blog.aisensiy.me/helm-and-kustomize)